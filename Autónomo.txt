Algoritmo utiizado para la navegación autónoma:

#include <Servo.h>  // incluimos librería servo
Servo myservo;      // instanciamos objeto desde librería servo

// Controles para módulo ultrasónico SR04 
const int Trig = 12; // pines para SR04
const int Echo = 13;

// pines para control PWM de velocidad de los motores
#define PWM1_PIN            5
#define PWM2_PIN            6      

// 74HCT595N Chip pins
#define SHCP_PIN            2                               // desplazamiento reloj
#define EN_PIN              7                               // toma de control
#define DATA_PIN            8                               // datos serie
#define STCP_PIN            4                               // control registro de memoria                 

// valores referencia para movimiento
const int Forward       = 92;                               // valor forward
const int Backward      = 163;                              // valor back
const int Turn_Left     = 149;                              // valor left translation
const int Turn_Right    = 106;                              // valor Right translation 
const int Top_Left      = 20;                               // valor Upper left mobile
const int Bottom_Left   = 129;                              // valor Lower left mobile
const int Top_Right     = 72;                               // valor Upper right mobile
const int Bottom_Right  = 34;                               // valor The lower right move
const int Stop          = 0;                                // valor stop
const int Contrarotate  = 172;                              // valor Counterclockwise rotation
const int Clockwise     = 83;                               // valor Rotate clockwise

int rightDistance = 0, leftDistance = 0, middleDistance = 0; // declaramos y definimos variables para distancias

float SR04(int Trig, int Echo) // función para medir distancia desde el módulo ultrasónico SR04
{
    digitalWrite(Trig, LOW);
    delayMicroseconds(2);
    digitalWrite(Trig, HIGH);
    delayMicroseconds(10);
    digitalWrite(Trig, LOW);
    float distance = pulseIn(Echo, HIGH) / 58.00;
    delay(10);
    return distance; // retorna la distancia
}

void setup() // zona setup para ajustes
{
    myservo.attach(9, 700, 2400); // definimos pin 9 para salida PWM (ángulo de servo)
    pinMode(Trig, OUTPUT); // pin trigger como salida
    pinMode(Echo, INPUT); // pin echo como entrada

    pinMode(SHCP_PIN, OUTPUT);  // ajuste de modo de funcionamiento del resto de pines
    pinMode(EN_PIN, OUTPUT);
    pinMode(DATA_PIN, OUTPUT);
    pinMode(STCP_PIN, OUTPUT);
    pinMode(PWM1_PIN, OUTPUT);
    pinMode(PWM2_PIN, OUTPUT);

    Serial.begin(9600); // inicializamos la UART a 9600 baudios
}

void loop() // bucle infinito
{
    middleDistance = SR04(Trig, Echo); // invocamos primeramente a SR04 y recuperamos valor para introducirlo en variable de lectura en distancia media
    Serial.print("distance:"); // imprimimos
    Serial.println(middleDistance);

    if (middleDistance <= 25) // si la distancia es inferior o igual a 25 cm
    {
        Motor(Stop, 0); // paramos motores
        delay(500); // esperamos 500ms
        myservo.write(10); // posicionamos servo en 10º (miramos a derechas)
        delay(500); // esperamos 500ms 
        rightDistance = SR04(Trig, Echo); // y volvemos a preguntar para introducirlo en la variable de distancia a derechas;

        delay(500);
        myservo.write(90);
        delay(500);
        myservo.write(170);
        delay(500);
        leftDistance = SR04(Trig, Echo); // obtenemos la distancia a la izquierda

        delay(500);
        myservo.write(90);
        delay(500);
        
        if (rightDistance <= 25 && leftDistance <= 25) { // si hay obstáculos en todas las direcciones
            Motor(Clockwise, 250); // giramos sobre sí mismo
            delay(1000); // ajusta el tiempo de giro según sea necesario
        }
        else if (rightDistance > leftDistance) { // si la distancia al obstáculo a derechas es mayor que el obstáculo en izquierda
            Motor(Stop, 0);
            delay(100);
            Motor(Backward, 180);
            delay(1000);
            Motor(Clockwise, 250); 
            delay(600);
        }
        else if (rightDistance < leftDistance) {
            Motor(Stop, 0);
            delay(100);
            Motor(Backward, 180);
            delay(1000);
            Motor(Contrarotate, 250);
            delay(600);
        }
        else {
            Motor(Backward, 180);
            delay(1000);
            Motor(Clockwise, 250); 
            delay(600);
        }
    }
    else // si no estamos a menos o igual de 25 cm de cualquier obstáculo
    {
        Motor(Forward, 250); // vamos hacia adelante a tope de velocidad
    }
}

void Motor(int Dir, int Speed) // función para mover motores, recibe 2 parámetros int, como valores de velocidad para cada motor
{
    analogWrite(PWM1_PIN, Speed); // volcamos en salida PWM la velocidad de cada motor
    analogWrite(PWM2_PIN, Speed);

    digitalWrite(STCP_PIN, LOW); // ajuste del resto de pines de control de los puentes en H
    shiftOut(DATA_PIN, SHCP_PIN, MSBFIRST, Dir);
    digitalWrite(STCP_PIN, HIGH);
}
